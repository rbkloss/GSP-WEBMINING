/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package PSO;

import dataStructures.PageAList;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 *
 * @author ricardo
 */
public class Particle implements ParticleInterface, Comparable<Particle> {

    private int size;
    private float fitness;
    private int frequency;
    private ArrayList<Integer> pos;
    private ArrayList<Integer> velocity;
    private ArrayList<Integer> localBest;
    private int sessions;
    private Random randomizer;
    PageAList pages;

    Particle(Random r, int size, int sessions, PageAList pages) {
        randomizer = r;
        pos = new ArrayList(size);
        velocity = new ArrayList(size);
        localBest = new ArrayList(size);
        this.size = size;
        this.pages = pages;
        this.sessions = sessions;

        if (r == null) {
            System.err.println("randomizer is null");
        }

        for (int i = 0; i < size; i++) {
            Integer newPage = r.nextInt(pages.size());
            pos.add(newPage);
            velocity.add(0);
            localBest.add(newPage);
        }
//        System.out.println("Particle generated by the Random Constructor : \n\t" + this.toString());
    }

    Particle(PageAList pages, int sessions, Integer[] sequence) {
        pos = new ArrayList(size);
        velocity = new ArrayList(size);
        localBest = new ArrayList(size);
        this.size = sequence.length;
        this.pages = pages;
        this.sessions = sessions;
        this.randomizer = new Random(0);

        for (int i = 0; i < sequence.length; i++) {
            pos.add(pages.getIndex(sequence[i]));
            localBest.add(pages.getIndex(sequence[i]));
        }
        for (int i = 0; i < size; i++) {
            velocity.add(0);
        }

//        System.out.println("Particle generated by the nonRandom Constructor : \n\t" + this.toString());
    }

    public static int[] calcIR(String filename, String token, int sessions) throws IOException {
        /*
         * IR = [log(mTransNum(m)) + log(nTransNum(n))]*Trans(m, n)/TotalTrans
         */
        int[] answer = new int[2];
        int MAX = 0;
        FileReader fr = new FileReader(filename);
        BufferedReader br = new BufferedReader(fr);
        String line;
        ArrayList<Session> sessionsList = new ArrayList<>();
        int transactions = 0;
        TreeSet<Integer> pages = new TreeSet<>();
        while ((line = br.readLine()) != null) {

            transactions++;
            String elements[] = line.split(token);

            Session newSession = new Session(elements.length);
            for (int i = 0; i < elements.length; i++) {
                pages.add(Integer.parseInt(elements[i]));
            }
            boolean incrementOcurred = false;
            for (Iterator<Session> itr = sessionsList.iterator(); itr.hasNext();) {
                Session s = itr.next();
                if (s.equals(newSession)) {
                    s.incrementFreq();
                    incrementOcurred = true;
                    break;
                }
            }
            if (!incrementOcurred) {
                sessionsList.add(newSession);
                Collections.sort(sessionsList);
            }

        }
        br.close();
        fr.close();

        System.out.println("Sessions Log : " + sessionsList.toString());

        MAX = sessionsList.get(sessionsList.size() - 1).getSessionSize();

        float IR = 0;
        for (int i = sessionsList.get(0).getSessionSize(); i < MAX; i++) {
            if (Session.getSession(sessionsList, i) == null) {
                continue;
            }
            for (int j = i + 1; j < MAX; j++) {
                if (Session.getSession(sessionsList, j) == null || i == j) {
                    continue;
                }
                //calculate IR
                // IR = [log(mTransNum(m)) + log(nTransNum(n))]*Trans(m,n)/TotalTrans
                int transMN = 0;
                for (int k = i; k <= j; k++) {
                    try {
                        transMN += Session.getSession(sessionsList, k).getSessionFreq();
                    } catch (Exception e) {

                        continue;
                    }
                    k++;
                }
                float newIR = (float) ((Math.log(i * Session.getSession(sessionsList, i).getSessionFreq()) + Math.log(j * Session.getSession(sessionsList, i).getSessionFreq())) * Math.log((float) transMN / (float) sessions));

                if (newIR > IR) {
                    IR = newIR;
                    answer[0] = i;
                    answer[1] = j;
                }
            }
        }

        return answer;
    }

    /**
     * Calculates the fitness of the swarm
     */
    public void calcFitness(int numberOfTransactions) {
        //Fitness(k) = confidence(k)X log(support(k)X length(k) + 1)
        //fitness(k) = support(k)*length(k)+1

//        System.out.println("Transactions " + numberOfTransactions + " Frequency " + frequency + " size" + this.getSize());

        fitness = (float) Math.log(((float) frequency / (float) numberOfTransactions) * (float) this.getSize() + 1f);
        System.out.println(this.toString());
//        System.out.println("fitness : " + fitness + " calculation : " + (float) (((float) frequency / (float) numberOfTransactions) * (float) this.getSize() + 1f));
    }

    @Override
    public void updateVelocity(ArrayList gBest) {
        //wvold + c1 rand( )(pbest − xid ) + c2 rand( )(gbest − xid ) 
        for (int i = 0; i < getSize(); i++) {
            setVelocity(i, (int) (getVelocity(i) + randomizer.nextFloat() * (getLocalBest(i) - getValue(i)) + randomizer.nextFloat() * ((Integer) gBest.get(i) - getValue(i))));
        }
    }

    @Override
    public void updatePosition(ArrayList gBest) {
        this.updateVelocity(gBest);
        for (int i = 0; i < getSize(); i++) {
            setValue(i, Math.abs(getValue(i) + getVelocity(i)) % this.pages.size());
        }
    }

    @Override
    public float getFitness() {
        return fitness;
    }

    public int getFreq() {
        return this.frequency;
    }

    public void setFreq(int freq) {
        this.frequency = freq;

    }

    public void incrementFreq() {
        frequency++;
    }

    @Override
    public int getValue(int index) {
        return pos.get(index);
    }

    @Override
    public int getVelocity(int index) {
        return velocity.get(index);
    }

    @Override
    public void setVelocity(int index, int newVelocity) {
        velocity.set(index, newVelocity);
    }

    @Override
    public void setFitness(float fitness) {
        this.fitness = fitness;
    }

    @Override
    public void setValue(int index, int value) {
        pos.set(index, value);
    }

    @Override
    public void setRandomizer(Random r) {
        this.randomizer = r;
    }

    @Override
    public int compareTo(Particle o) {
        if (this.getFitness() > o.getFitness()) {
            return 1;
        } else if (this.getFitness() < o.getFitness()) {
            return -1;
        } else {
            return 0;
        }
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public int getLocalBest(int index) {
        return localBest.get(index);
    }

    @Override
    public ArrayList<Integer> getParticle() {
        return pos;
    }

    public boolean isContained(Integer[] sequence) {

        Iterator<Integer> itr = this.convertFromIndexesToValues().iterator();
        if (!itr.hasNext()) {
            System.err.print("ERROR!\n" + "Particle is : " + this.toString());

        }
        try {
            Integer currentEl = itr.next();
            for (int i = 0; i < sequence.length; i++) {
                if (currentEl.equals(sequence[i])) {
                    if (!itr.hasNext()) {
//                        System.out.println("\t\t" + currentEl + " || " + sequence[i]);
                        return true;
                    } else {
                        currentEl = itr.next();
                    }
                }
            }
        } catch (NoSuchElementException e) {
            System.err.println("At isContained() caught a NoSuchElementException!");
        }
        return false;
    }

    public ArrayList<Integer> convertFromIndexesToValues() {
        ArrayList<Integer> answer = new ArrayList<>();
        for (int i = 0; i < this.getSize(); i++) {
            answer.add(pages.getValue(this.getValue(i)));
        }
        return answer;
    }

    public String toString() {
        String answer = new String();
        ArrayList<Integer> sequence = convertFromIndexesToValues();

//        answer += "\tSequence Indexes " + this.getParticle().toString() + " has " + this.getFitness() + " fitness\n";
        answer += "\tSequence Values :" + sequence.toString() + " has " + this.getFitness() + " fitness\n";

        return answer;
    }

    static class Session implements Comparable<Session> {

        int size;
        int freq;

        Session(int size) {
            this.size = size;
            this.freq = 1;
        }

        public int getSessionSize() {
            return size;
        }

        public int getSessionFreq() {
            return freq;
        }

        public void incrementFreq() {
            this.freq++;
        }

        public static Session getSession(ArrayList<Session> sessions, int sizeOfSession) {
            for (Iterator<Session> itr = sessions.iterator(); itr.hasNext();) {
                Session s = itr.next();
                if (s.getSessionSize() == sizeOfSession) {
                    return s;
                }
            }
            return null;
        }

        @Override
        public int compareTo(Session o) {
            if (this.size > o.size) {
                return 1;
            } else if (this.size < o.size) {
                return -1;
            } else {
                return 0;
            }
        }

        @Override
        public boolean equals(Object o) {
            Session s = (Session) o;
            if (this.size == s.size) {
                return true;
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            StringBuilder answer = new StringBuilder();
            answer.append("A session of Size : ").append(size).append(" occurs ").append(freq).append(" times.\n");
            return answer.toString();
        }
    }
}
